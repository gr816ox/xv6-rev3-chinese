## 3.2 Kernel  address space

​	Xv6 为每个进程维护一个页表，用于描述该进程的用户地址空间，此外还有一个单独的页表用于描述内核的地址空间。内核会配置其地址空间的布局，以便在可预测的虚拟地址上访问物理内存和各种硬件资源。图 3.3 展示了这种布局如何将内核的虚拟地址映射到物理地址。文件 `kernel/memlayout.h` 中声明了 xv6 内核内存布局所使用的常量。

![image-20250728094008013](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250728094008013.png)

​	QEMU 模拟了一台计算机，其中包含从物理地址 0x80000000 开始的 RAM（物理内存），并至少延续到 0x88000000，xv6 将这个结束地址称为 PHYSTOP。QEMU 的模拟还包括一些 I/O 设备，例如磁盘接口。QEMU 将这些设备接口以**内存映射控制寄存器**的形式暴露给软件，这些寄存器位于物理地址空间中低于 0x80000000 的位置。内核可以通过读写这些特殊的物理地址与设备进行交互；这样的读写操作是与设备硬件通信，而不是与 RAM 通信。第 4 章将介绍 xv6 如何与设备交互。

​	有一些内核虚拟地址并不是直接映射的：

- **跳板页（trampoline page）**：它被映射在虚拟地址空间的顶部；用户页表也具有相同的映射。第 4 章会讨论跳板页的作用，但在这里我们已经可以看到页表的一个有趣用途：一个物理页面（存放跳板代码）在内核的虚拟地址空间中被映射了两次——一次是在虚拟地址空间的顶部，另一次是通过直接映射。
  
- **内核栈页面（kernel stack pages）**：每个进程都有自己的内核栈，并且这些栈被映射在较高的虚拟地址处，这样在其下方就可以保留一个未映射的保护页（guard page）。这个保护页的页表项（PTE）是无效的（即 PTE_V 未设置），因此如果内核栈发生溢出，很可能会触发异常并导致内核崩溃（panic）。如果没有保护页，栈溢出就会覆盖其他内核内存，从而导致错误的操作行为。相比之下，引发崩溃是更好的选择。

​	虽然内核通过高地址映射来使用这些栈，但它们也可以通过直接映射的地址被内核访问。另一种设计可能只使用直接映射，并在直接映射的地址处使用这些栈。然而，在这种安排下，要提供保护页就需要取消映射那些原本指向物理内存的虚拟地址，这会使这些物理内存难以使用。

​	内核对跳板页以及内核代码段（kernel text）的页面使用权限 PTE_R 和 PTE_X 进行映射，表示内核可以从这些页面读取数据并执行指令。对于其他页面，内核使用权限 PTE_R 和 PTE_W 进行映射，使其可以读取和写入这些页面中的内存。而保护页的映射则是无效的（invalid）。



##  3.3 Code: creating an address space

### 3.3 代码：创建地址空间

​	大多数用于操作地址空间和页表的 xv6 代码都位于 `vm.c` 文件中（`kernel/vm.c:1`）。核心的数据结构是 `pagetable_t`，它实际上是一个指向 RISC-V 根页表页面的指针；`pagetable_t` 可以是内核页表，也可以是某个进程的页表。核心函数包括 `walk`（用于查找某个虚拟地址对应的 PTE）和 `mappages`（用于安装新的映射）。以 `kvm` 开头的函数用于操作内核页表；以 `uvm` 开头的函数用于操作用户页表；其他函数则两者都适用。`copyout` 和 `copyin` 用于在系统调用参数提供的用户虚拟地址之间复制数据；它们也位于 `vm.c` 中，因为需要显式地翻译这些地址才能找到对应的物理内存。

​	在启动序列的早期阶段，`main` 函数调用 `kvminit`（`kernel/vm.c:54`）来使用 `kvmmake`（`kernel/vm.c:20`）创建内核的页表。这个调用发生在 xv6 启用 RISC-V 分页机制之前，因此地址直接指向物理内存。`kvmmake` 首先分配一页物理内存来存放根页表页面。然后它调用 `kvmmap` 来安装内核所需的转换映射。这些映射包括内核的指令和数据、从 0 到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。`proc_mapstacks`（`kernel/proc.c:33`）为每个进程分配一个内核栈。它调用 `kvmmap` 将每个栈映射到由 `KSTACK` 生成的虚拟地址上，这样就在栈下方留出了无效的栈保护页的空间。

​	`kvmmap`（`kernel/vm.c:132`）调用 `mappages`（`kernel/vm.c:143`），后者为一段虚拟地址范围安装映射到相应物理地址范围的 PTE。它以页面间隔为单位，分别为范围内的每个虚拟地址执行此操作。对于每个要映射的虚拟地址，`mappages` 调用 `walk` 来找到该地址的 PTE 地址。然后它初始化 PTE，保存相关的物理页号、所需的权限（PTE_W、PTE_X 和/或 PTE_R），以及设置 PTE_V 来标记 PTE 为有效（`kernel/vm.c:158`）。

​	`walk`（`kernel/vm.c:86`）模拟 RISC-V 分页硬件来查找虚拟地址的 PTE（见图 3.2）。`walk` 每次下降 9 位来遍历三级页表。它使用每级的 9 位虚拟地址来找到下一级页表或最终页面的 PTE（`kernel/vm.c:92`）。如果 PTE 无效，则说明所需的页面尚未分配；如果设置了 `alloc` 参数，`walk` 会分配一个新的页表页面并将它的物理地址放入 PTE 中。它返回树中最底层 PTE 的地址（`kernel/vm.c:102`）。

​	上述代码依赖于物理内存被直接映射到内核虚拟地址空间中。例如，当 `walk` 下降到页表的各级时，它从 PTE 中提取下一级页表的（物理）地址（`kernel/vm.c:94`），然后将该地址作为虚拟地址使用来获取下一级的 PTE（`kernel/vm.c:92`）。

`	main` 调用 `kvminithart`（`kernel/vm.c:62`）来安装内核页表。它将根页表页面的物理地址写入 `satp` 寄存器。此后 CPU 将使用内核页表来翻译地址。由于内核使用恒等映射，现在下一条指令的虚拟地址将映射到正确的物理内存地址。

​	每个 RISC-V CPU 都在 Translation Look-aside Buffer (TLB) 中缓存页表条目，当 xv6 更改页表时，必须告诉 CPU 使相应的缓存 TLB 条目失效。如果不这样做，那么在某个时刻 TLB 可能会使用旧的缓存映射，指向一个在此期间已被分配给其他进程的物理页面，结果某个进程就可能能够篡改其他进程的内存。RISC-V 提供了 `sfence.vma` 指令来刷新当前 CPU 的 TLB。xv6 在 `kvminithart` 中重新加载 `satp` 寄存器后执行 `sfence.vma`，并在切换到用户页表返回用户空间之前的跳板代码中执行（`kernel/trampoline.S:89`）。

​	在更改 `satp` 之前也需要执行 `sfence.vma`，以便等待所有未完成的加载和存储操作完成。这种等待确保了之前的页表更新已经完成，并确保之前的加载和存储操作使用旧的页表，而不是新的页表。

​	为了避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符（ASID）[3]。内核可以只刷新特定地址空间的 TLB 条目。xv6 没有使用这个特性。

​	This is a test line123.