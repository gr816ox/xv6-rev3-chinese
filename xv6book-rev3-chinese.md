## 3.2 Kernel  address space

​	Xv6 为每个进程维护一个页表，用于描述该进程的用户地址空间，此外还有一个单独的页表用于描述内核的地址空间。内核会配置其地址空间的布局，以便在可预测的虚拟地址上访问物理内存和各种硬件资源。图 3.3 展示了这种布局如何将内核的虚拟地址映射到物理地址。文件 `kernel/memlayout.h` 中声明了 xv6 内核内存布局所使用的常量。

![image-20250728094008013](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250728094008013.png)

​	QEMU 模拟了一台计算机，其中包含从物理地址 0x80000000 开始的 RAM（物理内存），并至少延续到 0x88000000，xv6 将这个结束地址称为 PHYSTOP。QEMU 的模拟还包括一些 I/O 设备，例如磁盘接口。QEMU 将这些设备接口以**内存映射控制寄存器**的形式暴露给软件，这些寄存器位于物理地址空间中低于 0x80000000 的位置。内核可以通过读写这些特殊的物理地址与设备进行交互；这样的读写操作是与设备硬件通信，而不是与 RAM 通信。第 4 章将介绍 xv6 如何与设备交互。

​	有一些内核虚拟地址并不是直接映射的：

- **跳板页（trampoline page）**：它被映射在虚拟地址空间的顶部；用户页表也具有相同的映射。第 4 章会讨论跳板页的作用，但在这里我们已经可以看到页表的一个有趣用途：一个物理页面（存放跳板代码）在内核的虚拟地址空间中被映射了两次——一次是在虚拟地址空间的顶部，另一次是通过直接映射。

- **内核栈页面（kernel stack pages）**：每个进程都有自己的内核栈，并且这些栈被映射在较高的虚拟地址处，这样在其下方就可以保留一个未映射的保护页（guard page）。这个保护页的页表项（PTE）是无效的（即 PTE_V 未设置），因此如果内核栈发生溢出，很可能会触发异常并导致内核崩溃（panic）。如果没有保护页，栈溢出就会覆盖其他内核内存，从而导致错误的操作行为。相比之下，引发崩溃是更好的选择。

​	虽然内核通过高地址映射来使用这些栈，但它们也可以通过直接映射的地址被内核访问。另一种设计可能只使用直接映射，并在直接映射的地址处使用这些栈。然而，在这种安排下，要提供保护页就需要取消映射那些原本指向物理内存的虚拟地址，这会使这些物理内存难以使用。

​	内核对跳板页以及内核代码段（kernel text）的页面使用权限 PTE_R 和 PTE_X 进行映射，表示内核可以从这些页面读取数据并执行指令。对于其他页面，内核使用权限 PTE_R 和 PTE_W 进行映射，使其可以读取和写入这些页面中的内存。而保护页的映射则是无效的（invalid）。



##  3.3 Code: creating an address space

### 3.3 代码：创建地址空间

​	大多数用于操作地址空间和页表的 xv6 代码都位于 `vm.c` 文件中（`kernel/vm.c:1`）。核心的数据结构是 `pagetable_t`，它实际上是一个指向 RISC-V 根页表页面的指针；`pagetable_t` 可以是内核页表，也可以是某个进程的页表。核心函数包括 `walk`（用于查找某个虚拟地址对应的 PTE）和 `mappages`（用于安装新的映射）。以 `kvm` 开头的函数用于操作内核页表；以 `uvm` 开头的函数用于操作用户页表；其他函数则两者都适用。`copyout` 和 `copyin` 用于在系统调用参数提供的用户虚拟地址之间复制数据；它们也位于 `vm.c` 中，因为需要显式地翻译这些地址才能找到对应的物理内存。

​	在启动序列的早期阶段，`main` 函数调用 `kvminit`（`kernel/vm.c:54`）来使用 `kvmmake`（`kernel/vm.c:20`）创建内核的页表。这个调用发生在 xv6 启用 RISC-V 分页机制之前，因此地址直接指向物理内存。`kvmmake` 首先分配一页物理内存来存放根页表页面。然后它调用 `kvmmap` 来安装内核所需的转换映射。这些映射包括内核的指令和数据、从 0 到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。`proc_mapstacks`（`kernel/proc.c:33`）为每个进程分配一个内核栈。它调用 `kvmmap` 将每个栈映射到由 `KSTACK` 生成的虚拟地址上，这样就在栈下方留出了无效的栈保护页的空间。

​	`kvmmap`（`kernel/vm.c:132`）调用 `mappages`（`kernel/vm.c:143`），后者为一段虚拟地址范围安装映射到相应物理地址范围的 PTE。它以页面间隔为单位，分别为范围内的每个虚拟地址执行此操作。对于每个要映射的虚拟地址，`mappages` 调用 `walk` 来找到该地址的 PTE 地址。然后它初始化 PTE，保存相关的物理页号、所需的权限（PTE_W、PTE_X 和/或 PTE_R），以及设置 PTE_V 来标记 PTE 为有效（`kernel/vm.c:158`）。

​	`walk`（`kernel/vm.c:86`）模拟 RISC-V 分页硬件来查找虚拟地址的 PTE（见图 3.2）。`walk` 每次下降 9 位来遍历三级页表。它使用每级的 9 位虚拟地址来找到下一级页表或最终页面的 PTE（`kernel/vm.c:92`）。如果 PTE 无效，则说明所需的页面尚未分配；如果设置了 `alloc` 参数，`walk` 会分配一个新的页表页面并将它的物理地址放入 PTE 中。它返回树中最底层 PTE 的地址（`kernel/vm.c:102`）。

​	上述代码依赖于物理内存被直接映射到内核虚拟地址空间中。例如，当 `walk` 下降到页表的各级时，它从 PTE 中提取下一级页表的（物理）地址（`kernel/vm.c:94`），然后将该地址作为虚拟地址使用来获取下一级的 PTE（`kernel/vm.c:92`）。

`	main` 调用 `kvminithart`（`kernel/vm.c:62`）来安装内核页表。它将根页表页面的物理地址写入 `satp` 寄存器。此后 CPU 将使用内核页表来翻译地址。由于内核使用恒等映射，现在下一条指令的虚拟地址将映射到正确的物理内存地址。

​	每个 RISC-V CPU 都在 Translation Look-aside Buffer (TLB) 中缓存页表条目，当 xv6 更改页表时，必须告诉 CPU 使相应的缓存 TLB 条目失效。如果不这样做，那么在某个时刻 TLB 可能会使用旧的缓存映射，指向一个在此期间已被分配给其他进程的物理页面，结果某个进程就可能能够篡改其他进程的内存。RISC-V 提供了 `sfence.vma` 指令来刷新当前 CPU 的 TLB。xv6 在 `kvminithart` 中重新加载 `satp` 寄存器后执行 `sfence.vma`，并在切换到用户页表返回用户空间之前的跳板代码中执行（`kernel/trampoline.S:89`）。

​	在更改 `satp` 之前也需要执行 `sfence.vma`，以便等待所有未完成的加载和存储操作完成。这种等待确保了之前的页表更新已经完成，并确保之前的加载和存储操作使用旧的页表，而不是新的页表。

​	为了避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符（ASID）[3]。内核可以只刷新特定地址空间的 TLB 条目。xv6 没有使用这个特性。



## 3.6 Process address space

​	每个进程都有独立的页表，当 xv6 在进程之间切换时，也会切换页表。图 3.4 比图 2.3 更详细地展示了进程的地址空间。一个进程的用户内存从虚拟地址 0 开始，最多可增长到 MAXVA（kernel/riscv.h:360），理论上允许一个进程访问 256 GB 的内存。

​	一个进程的地址空间由多个页面组成，包括存放程序代码的页面（xv6 使用 PTE_R、PTE_X 和 PTE_U 权限映射）、存放程序预初始化数据的页面、一个用于栈的页面，以及用于堆的页面。xv6 使用 PTE_R、PTE_W 和 PTE_U 权限来映射数据、栈和堆。

​	在用户地址空间中使用权限控制是一种常见的增强进程安全性的技术。如果程序代码段被映射为可写（PTE_W），那么进程可能会意外修改自身的程序代码；例如，编程错误可能导致程序向空指针（地址 0）写入数据，从而修改位于地址 0 处的指令，然后继续运行，可能造成更严重的破坏。为了立即检测此类错误，xv6 将代码段以不可写的方式映射（不设置 PTE_W）；如果程序意外尝试向地址 0 写入数据，硬件将拒绝执行该写操作并触发页错误（参见第 4.6 节）。随后内核会终止该进程，并输出一条提示信息，帮助开发者定位问题。

​	类似地，通过将数据段映射为不可执行（不设置 PTE_X），用户程序就不会意外跳转到数据区域的某个地址并开始执行该处的代码。

​	在实际应用中，仔细设置内存权限以增强进程安全性，也有助于防御安全攻击。攻击者可能会向程序（例如 Web 服务器）提供精心构造的输入，触发程序中的漏洞，企图将该漏洞转化为可利用的攻击手段 [14]。仔细设置内存权限，以及诸如随机化用户地址空间布局等其他技术，都能使此类攻击更加困难。

​	栈仅占用一个页面，图中显示的是 exec 创建时栈的初始内容。命令行参数的字符串以及指向这些字符串的指针数组位于栈的最顶端。其下方是一些值，使得程序可以从 main 函数开始执行，就像函数 `main(argc, argv)` 刚被调用一样。

​	为了检测用户栈溢出已分配的栈内存，xv6 在栈下方设置了一个不可访问的“保护页”（guard page），方法是清除该页表项的 PTE_U 标志。当用户栈溢出并尝试访问栈下方的地址时，由于保护页对用户模式下的程序不可访问，硬件将产生页错误异常。在真实的操作系统中，可能会选择在栈溢出时自动为用户栈分配更多内存。

​	当进程向 xv6 请求更多用户内存时，xv6 会扩展该进程的堆。xv6 首先使用`kalloc` 分配物理页面，然后在进程的页表中添加指向这些新物理页面的页表项（PTE），并设置这些 PTE 中的 PTE_W、PTE_R、PTE_U 和 PTE_V 标志。大多数进程并不会使用整个用户地址空间；xv6 会将未使用的页表项中的 PTE_V 标志保持清除状态。

​	我们在这里可以看到页表的一些良好应用实例。首先，不同进程的页表将用户虚拟地址映射到不同的物理内存页面，从而确保每个进程拥有独立的用户内存空间。其次，每个进程看到的内存是始于虚拟地址 0 的连续地址空间，而其实际物理内存可以是不连续的。第三，内核在用户地址空间的顶部映射了一个包含“跳板”（trampoline）代码的页面（不设置 PTE_U），因此这一个物理页面出现在所有进程的地址空间中，但只能由内核使用。



## 3.7 Code：sbrk

​	`sbrk` 是进程用于缩小或扩大其内存空间的系统调用，该系统调用由函数` growproc` 实现（kernel/proc.c:260）。`growproc`根据参数 n 的正负，调用` uvmalloc` 或 `uvmdealloc`：若 n 为正，则扩展内存；若 n 为负，则缩小内存。`uvmalloc`（kernel/vm.c:226）通过 `kalloc` 分配物理内存，并使用 `mappages` 函数将相应的页表项（PTE）添加到用户页表中，完成虚拟地址到物理地址的映射。`uvmdealloc` 则调用 `uvmunmap`（kernel/vm.c:171），后者通过 `walk` 函数在页表中查找对应的 PTE，并使用 `kfree` 释放这些 PTE 所指向的物理内存。

​	xv6 不仅使用进程的页表来告诉硬件如何进行用户虚拟地址到物理地址的映射，还将页表作为记录该进程所分配物理内存页的唯一依据。正因如此，在释放用户内存（如 `uvmunmap` 中）时，必须检查用户页表，以确定哪些物理页面需要被释放。



## 3.8 Code：exec

​	exec 是一个系统调用，它用从文件中读取的数据替换进程的用户地址空间，这个文件被称为二进制文件或可执行文件。二进制文件通常是编译器和链接器的输出，包含机器指令和程序数据。exec（`kernel/exec.c:23`）使用 namei（`kernel/exec.c:36`）打开指定的二进制文件路径，namei 将在第 8 章中解释。然后，它读取 ELF 头部。xv6 的二进制文件采用广泛使用的 ELF 格式，定义在（`kernel/elf.h`）中。ELF 二进制文件由一个 ELF 头部 struct elfhdr（`kernel/elf.h:6`）组成，后面跟着一系列程序段头部 struct proghdr（`kernel/elf.h:25`）。每个 proghdr 描述了必须加载到内存中的应用程序段；xv6 程序有两个程序段头部：一个用于指令，一个用于数据。

​	第一步是快速检查文件是否可能包含 ELF 二进制文件。ELF 二进制文件以四个字节的"魔数" 0x7F, 'E', 'L', 'F' 或 ELF_MAGIC（`kernel/elf.h:3`）开头。如果 ELF 头部有正确的魔数，exec 就假设二进制文件格式正确。exec 使用 proc_pagetable（`kernel/exec.c:49`）分配一个新的没有用户映射的页表，使用 uvmalloc（`kernel/exec.c:65`）为每个 ELF 段分配内存，并使用 loadseg（`kernel/exec.c:10`）将每个段加载到内存中。loadseg 使用 walkaddr 找到分配内存的物理地址来写入 ELF 段的每个页面，并使用 readi 从文件中读取。

​	/init（第一个通过 exec 创建的用户程序）的程序段头部如下所示：

​	我们看到文本段应该在内存的虚拟地址 0x0 处加载（没有写权限），内容来自文件中偏移量 0x1000 处。我们还看到数据应该在地址 0x1000 处加载，这在页面边界上，并且没有可执行权限。

​	程序段头部的 filesz 可能小于 memsz，表示它们之间的间隙应该用零填充（用于 C 全局变量）而不是从文件中读取。对于 /init，数据 filesz 是 0x10 字节，memsz 是 0x30 字节，因此 uvmalloc 分配足够的物理内存来容纳 0x30 字节，但只从 /init 文件中读取 0x10 字节。

​	现在 exec 分配并初始化用户栈。它只分配一个栈页面。exec 逐个将参数字符串复制到栈顶，在 ustack 中记录指向它们的指针。它在将传递给 main 的 argv 列表末尾放置一个空指针。ustack 中的前三个条目是假的返回程序计数器、argc 和 argv 指针。

​	exec 在栈页面下方放置一个不可访问的页面，这样尝试使用超过一个页面的程序将会出现错误。这个不可访问的页面也允许 exec 处理过大的参数；在这种情况下，exec 用来将参数复制到栈的 copyout（`kernel/vm.c:352`）函数会注意到目标页面不可访问，并返回 -1。

​	在准备新内存镜像期间，如果 exec 检测到错误（如无效的程序段），它会跳转到标签 bad，释放新镜像，并返回 -1。exec 必须等到确定系统调用会成功后才能释放旧镜像：如果旧镜像消失了，系统调用就无法向它返回 -1。exec 中的唯一错误情况发生在镜像创建期间。一旦镜像完成，exec 就可以提交到新页表（`kernel/exec.c:125`）并释放旧页表（`kernel/exec.c:129`）。

​	exec 将 ELF 文件中的字节加载到 ELF 文件指定的内存地址。用户或进程可以在 ELF 文件中放置任何他们想要的地址。因此 exec 是有风险的，因为 ELF 文件中的地址可能指向内核，无论是意外还是故意。对一个不小心的内核来说，后果可能从崩溃到恶意破坏内核的隔离机制（即安全漏洞）不等。xv6 执行许多检查来避免这些风险。例如 if(ph.vaddr + ph.memsz < ph.vaddr) 检查总和是否会溢出 64 位整数。危险在于用户可以构造一个 ELF 二进制文件，其中 ph.vaddr 指向用户选择的地址，而 ph.memsz 足够大，使得总和溢出到 0x1000，这看起来像是一个有效值。在早期版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读/写），用户可以选择对应内核内存的地址，从而将数据从 ELF 二进制文件复制到内核中。在 RISC-V 版本的 xv6 中不会发生这种情况，因为内核有自己独立的页表；loadseg 加载到进程的页表中，而不是内核的页表中。

​	内核开发人员很容易遗漏关键检查，而现实世界的内核长期以来都有缺少检查的历史，这些检查的缺失可能被用户程序利用来获得内核权限。xv6 可能没有完全验证提供给内核的用户级数据，恶意用户程序可能能够利用这一点来绕过 xv6 的隔离机制。



# Chapter 4

#  Traps and system calls

​	有三种事件会导致 CPU 暂停正常指令执行，并强制将控制权转移到处理该事件的特殊代码。第一种情况是系统调用，当用户程序执行 ecall 指令来请求内核为它做某事时发生。第二种情况是异常：指令（用户或内核）做了某些非法操作，比如除零或使用无效的虚拟地址。第三种情况是设备中断，当设备发出需要关注的信号时发生，例如当磁盘硬件完成读写请求时。

​	本书使用"陷阱"（trap）作为这些情况的通用术语。通常在陷阱发生时正在执行的代码之后需要恢复执行，并且不应该需要知道发生了任何特殊的事情。也就是说，我们通常希望陷阱是透明的；这对于设备中断尤其重要，因为被中断的代码通常不会预期到中断的发生。通常的序列是：陷阱强制将控制权转移到内核；内核保存寄存器和其他状态以便执行可以恢复；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态并从陷阱返回；原始代码从它中断的地方继续执行。

​	xv6 在内核中处理所有陷阱；陷阱不会传递给用户代码。在内核中处理系统调用是很自然的。对于中断来说也是合理的，因为隔离要求只有内核被允许使用设备，并且因为内核是方便的机制来在多个进程之间共享设备。对于异常来说也是合理的，因为 xv6 通过杀死违规程序来响应来自用户空间的所有异常。

​	xv6 陷阱处理分为四个阶段：RISC-V CPU 执行的硬件操作，一些为内核 C 代码准备路径的汇编指令，决定如何处理陷阱的 C 函数，以及系统调用或设备驱动服务例程。虽然三种陷阱类型之间的共性表明内核可以用单一代码路径处理所有陷阱，但实际上为三种不同情况使用单独代码是很方便的：来自用户空间的陷阱、来自内核空间的陷阱，以及定时器中断。处理陷阱的内核代码（汇编或 C）通常被称为处理程序；处理程序的第一条指令通常用汇编语言编写（而不是 C 语言），有时被称为向量。

好的，这是您提供的文本内容的中文翻译：

## **4.1 RISC-V 陷阱机制**

每个 RISC-V CPU 都有一组控制寄存器，内核可以写入这些寄存器来告诉 CPU 如何处理陷阱，内核也可以读取这些寄存器来了解发生的陷阱。完整的细节在 RISC-V 文档中 [3]。`riscv.h` (kernel/riscv.h:1) 包含了 xv6 使用的定义。以下是最重要的寄存器的概述：

*   **stvec**：内核在此写入其陷阱处理程序的地址；RISC-V 跳转到 `stvec` 中的地址来处理陷阱。
*   **sepc**：当陷阱发生时，RISC-V 将程序计数器（pc）保存在这里（因为 pc 随后会被 `stvec` 的值覆盖）。`sret`（从陷阱返回）指令将 `sepc` 复制到 pc。内核可以写 `sepc` 来控制 `sret` 去往何处。
*   **scause**：RISC-V 在这里放入一个数字，用来描述陷阱的原因。
*   **sscratch**：陷阱处理程序代码使用 `sscratch` 来帮助它避免在保存用户寄存器之前覆盖它们。
*   **sstatus**：`sstatus` 中的 SIE 位控制设备中断是否启用。如果内核清除了 SIE，RISC-V 将推迟设备中断，直到内核设置 SIE。SPP 位指示陷阱是来自用户模式还是监管模式，并控制 `sret` 返回到哪种模式。

上述寄存器与在监管模式下处理的陷阱相关，并且在用户模式下无法读取或写入。还有一组类似的控制寄存器用于在机器模式下处理的陷阱；xv6 仅在定时器中断的特殊情况下使用它们。多核芯片上的每个 CPU 都有自己的这组寄存器，并且在任何给定时间可能有多个 CPU 正在处理陷阱。

当需要强制执行陷阱时，RISC-V 硬件会为所有陷阱类型（定时器中断除外）执行以下操作：

1.  如果陷阱是设备中断，并且 `sstatus` 的 SIE 位被清除，则不执行以下任何操作。
2.  通过清除 `sstatus` 中的 SIE 位来禁用中断。
3.  将 pc 复制到 `sepc`。
4.  在 `sstatus` 的 SPP 位中保存当前模式（用户或监管）。
5.  设置 `scause` 以反映陷阱的原因。
6.  将模式设置为监管模式。
7.  将 `stvec` 复制到 pc。
8.  开始在新的 pc 处执行。

请注意，CPU 不会切换到内核页表，不会切换到内核中的堆栈，也不会保存除 pc 之外的任何寄存器。内核软件必须执行这些任务。CPU 在陷阱期间执行最少工作的原因之一是为了给软件提供灵活性；例如，某些操作系统在某些情况下省略页表切换以提高陷阱性能。

值得思考的是，是否可以省略上述列出的任何步骤，或许是为了寻求更快的陷阱。虽然在某些情况下更简单的序列可以工作，但通常省略许多步骤将是危险的。例如，假设 CPU 没有切换程序计数器。那么来自用户空间的陷阱可能会在仍然运行用户指令的同时切换到监管模式。这些用户指令可能会破坏用户/内核隔离，例如通过修改 `satp` 寄存器使其指向允许访问所有物理内存的页表。因此，CPU 切换到内核指定的指令地址（即 `stvec`）是重要的。

## **4.2 来自用户空间的陷阱**

Xv6 根据陷阱是在内核还是在用户代码中执行时发生而不同地处理陷阱。这里是来自用户代码的陷阱的故事；第 4.5 节描述了来自内核代码的陷阱。

当用户程序执行系统调用（`ecall` 指令）、执行非法操作或设备中断时，可能会在用户空间执行时发生陷阱。来自用户空间的陷阱的高级路径是 `uservec` (kernel/trampoline.S:21)，然后是 `usertrap` (kernel/trap.c:37)；返回时是 `usertrapret` (kernel/trap.c:90)，然后是 `userret` (kernel/trampoline.S:101)。

xv6 陷阱处理设计的一个主要限制是 RISC-V 硬件在强制执行陷阱时不会切换页表。这意味着 `stvec` 中的陷阱处理程序地址必须在用户页表中具有有效的映射，因为这是陷阱处理代码开始执行时生效的页表。此外，xv6 的陷阱处理代码需要切换到内核页表；为了能够在切换后继续执行，内核页表也必须对 `stvec` 指向的处理程序具有映射。

xv6 使用一个**蹦床页 (trampoline page)** 来满足这些要求。蹦床页包含 `uservec`，即 `stvec` 指向的 xv6 陷阱处理代码。蹦床页映射在每个进程的页表中的地址 `TRAMPOLINE`，该地址位于虚拟地址空间的顶部，因此它将在程序自己使用的内存之上。蹦床页也映射在内核页表中的地址 `TRAMPOLINE`。参见图 2.3 和图 3.3。

因为蹦床页映射在用户页表中，并且没有 `PTE_U` 标志，所以陷阱可以在监管模式下开始在那里执行。因为蹦床页在内核地址空间中映射在相同的地址，所以陷阱处理程序在切换到内核页表后可以继续执行。

`uservec` 陷阱处理程序的代码在 `trampoline.S` (kernel/trampoline.S:21) 中。当 `uservec` 开始时，所有 32 个寄存器都包含被中断的用户代码拥有的值。这 32 个值需要保存在内存中的某个地方，以便在陷阱返回用户空间时可以恢复它们。将值存储到内存需要使用寄存器来保存地址，但在此时没有通用寄存器可用！幸运的是，RISC-V 提供了 `sscratch` 寄存器作为帮助。`uservec` 开头的 `csrw` 指令将 `a0` 保存到 `sscratch`。现在 `uservec` 有了一个寄存器 (`a0`) 可以使用。

`uservec` 的下一个任务是保存 32 个用户寄存器。内核为每个进程分配一个内存页，用于 `trapframe` 结构，该结构（除其他外）有空间保存 32 个用户寄存器（kernel/proc.h:43）。因为 `satp` 仍然指向用户页表，`uservec` 需要 `trapframe` 映射在用户地址空间中。xv6 在每个进程的用户页表中将该进程的 `trapframe` 映射在虚拟地址 `TRAPFRAME`；`TRAPFRAME` 位于 `TRAMPOLINE` 下方一点。进程的 `p->trapframe` 也指向 `trapframe`，尽管它指向物理地址，以便内核可以通过内核页表使用它。

因此，`uservec` 将地址 `TRAPFRAME` 加载到 `a0` 中，并将所有用户寄存器保存在那里，包括从 `sscratch` 读回的用户 `a0`。陷阱帧包含当前进程的内核堆栈地址、当前 CPU 的 `hartid`、`usertrap` 函数的地址以及内核页表的地址。`uservec` 检索这些值，将 `satp` 切换到内核页表，然后调用 `usertrap`。

`usertrap` 的工作是确定陷阱的原因，处理它，然后返回 (kernel/trap.c:37)。它首先更改 `stvec`，以便在内核中的陷阱将由 `kernelvec` 而不是 `uservec` 处理。它保存 `sepc` 寄存器（保存的用户程序计数器），因为 `usertrap` 可能会调用 `yield` 切换到另一个进程的内核线程，而该进程可能会返回到用户空间，在此过程中会修改 `sepc`。

如果陷阱是系统调用，`usertrap` 调用 `syscall` 来处理它；如果是设备中断，则调用 `devintr`；否则就是异常，内核会杀死出错的进程。在系统调用的情况下，系统调用路径会将保存的用户程序计数器加四，因为 RISC-V 在系统调用时，将程序指针指向 `ecall` 指令，但用户代码需要在后续指令处恢复执行。

在返回的路上，`usertrap` 会检查进程是否已被杀死或是否应该让出 CPU（如果此陷阱是定时器中断）。

返回用户空间的第一步是调用 `usertrapret` (kernel/trap.c:90)。此函数设置 RISC-V 控制寄存器，为将来从用户空间进行的陷阱做准备。这包括将 `stvec` 更改为指向 `uservec`，准备 `uservec` 依赖的陷阱帧字段，并将 `sepc` 设置为先前保存的用户程序计数器。

最后，`usertrapret` 调用映射在用户和内核页表中的蹦床页上的 `userret`；原因是 `userret` 中的汇编代码将切换页表。`usertrapret` 对 `userret` 的调用通过 `a0` 传递指向进程用户页表的指针 (kernel/trampoline.S:101)。`userret` 将 `satp` 切换到进程的用户页表。回想一下，用户页表映射了蹦床页和 `TRAPFRAME`，但没有映射内核中的其他任何内容。用户和内核页表中蹦床页在相同虚拟地址的映射允许 `userret` 在更改 `satp` 后继续执行。从这一点开始，`userret` 可以使用的唯一数据是寄存器内容和陷阱帧的内容。

`userret` 将 `TRAPFRAME` 地址加载到 `a0` 中，通过 `a0` 从陷阱帧恢复保存的用户寄存器，恢复保存的用户 `a0`，并执行 `sret` 以返回用户空间。

## **4.3 代码：调用系统调用**

第 2 章以 `initcode.S` 调用 `exec` 系统调用结束 (user/initcode.S:11)。让我们看看用户调用是如何传递到内核中 `exec` 系统调用实现的。

`initcode.S` 将 `exec` 的参数放在寄存器 `a0` 和 `a1` 中，并将系统调用号放在 `a7` 中。系统调用号与 `syscalls` 数组中的条目匹配，该数组是一个函数指针表 (kernel/syscall.c:107)。`ecall` 指令陷入内核，导致 `uservec`、`usertrap`，然后是 `syscall` 执行，如上所述。

`syscall` (kernel/syscall.c:132) 从陷阱帧中保存的 `a7` 中检索系统调用号，并使用它作为索引进入 `syscalls`。对于第一个系统调用，`a7` 包含 `SYS_exec` (kernel/syscall.h:8)，导致调用系统调用实现函数 `sys_exec`。

当 `sys_exec` 返回时，`syscall` 将其返回值记录在 `p->trapframe->a0` 中。这将导致原始的用户空间 `exec()` 调用返回该值，因为 RISC-V 上的 C 调用约定将返回值放在 `a0` 中。系统调用通常返回负数表示错误，返回零或正数表示成功。如果系统调用号无效，`syscall` 会打印错误并返回 -1。

## **4.4 代码：系统调用参数**

内核中的系统调用实现需要找到用户代码传递的参数。因为用户代码调用系统调用包装函数，所以参数最初放置在 RISC-V C 调用约定放置它们的位置：寄存器中。内核陷阱代码将用户寄存器保存到当前进程的陷阱帧中，内核代码可以在那里找到它们。内核函数 `argint`、`argaddr` 和 `argfd` 从陷阱帧中检索第 n 个系统调用参数，分别作为整数、指针或文件描述符。它们都调用 `argraw` 来检索适当的保存的用户寄存器 (kernel/syscall.c:34)。

一些系统调用传递指针作为参数，内核必须使用这些指针来读取或写入用户内存。例如，`exec` 系统调用向内核传递一个指针数组，这些指针引用用户空间中的字符串参数。这些指针带来了两个挑战。首先，用户程序可能有错误或恶意，可能会向内核传递无效指针或旨在欺骗内核访问内核内存而不是用户内存的指针。其次，xv6 内核页表映射与用户页表映射不同，因此内核无法使用普通指令从用户提供的地址加载或存储。

内核实现了可以安全地在用户提供的地址之间传输数据的函数。`fetchstr` 就是一个例子 (kernel/syscall.c:25)。文件系统调用（如 `exec`）使用 `fetchstr` 从用户空间检索字符串文件名参数。`fetchstr` 调用 `copyinstr` 来完成繁重的工作。`copyinstr` (kernel/vm.c:403) 从用户页表 `pagetable` 中的虚拟地址 `srcva` 复制最多 `max` 字节到 `dst`。由于 `pagetable` 不是当前页表，`copyinstr` 使用 `walkaddr`（调用 `walk`）在 `pagetable` 中查找 `srcva`，产生物理地址 `pa0`。内核将每个物理 RAM 地址映射到相应的内核虚拟地址，因此 `copyinstr` 可以直接将字符串字节从 `pa0` 复制到 `dst`。`walkaddr` (kernel/vm.c:109) 检查用户提供的虚拟地址是否是进程用户地址空间的一部分，因此程序无法欺骗内核读取其他内存。一个类似的函数 `copyout` 将数据从内核复制到用户提供的地址。

## **4.5 来自内核空间的陷阱**

xv6 根据执行的是用户代码还是内核代码，以不同的方式配置 CPU 陷阱寄存器。当内核在 CPU 上执行时，内核将 `stvec` 指向 `kernelvec` (kernel/kernelvec.S:12) 的汇编代码。由于 xv6 已经在内核中，`kernelvec` 可以依赖于 `satp` 被设置为内核页表，并且堆栈指针引用有效的内核堆栈。

`kernelvec` 将所有 32 个寄存器推入堆栈，以便稍后可以恢复它们，从而使被中断的内核代码可以不受干扰地恢复。`kernelvec` 将寄存器保存在被中断的内核线程的堆栈上，这是有道理的，因为寄存器值属于该线程。如果陷阱导致切换到不同的线程，这一点尤其重要——在这种情况下，陷阱实际上将从新线程的堆栈返回，将被中断线程的保存寄存器安全地留在其堆栈上。

`kernelvec` 在保存寄存器后跳转到 `kerneltrap` (kernel/trap.c:135)。`kerneltrap` 为两种类型的陷阱做好了准备：设备中断和异常。它调用 `devintr` (kernel/trap.c:178) 来检查和处理前者。如果陷阱不是设备中断，那它一定是异常，如果发生在 xv6 内核中，这总是一个致命错误；内核调用 `panic` 并停止执行。

如果 `kerneltrap` 是由于定时器中断而被调用，并且正在运行进程的内核线程（而不是调度程序线程），`kerneltrap` 会调用 `yield` 来让其他线程有机会运行。在某个时候，这些线程中的一个会 `yield`，让我们的线程及其 `kerneltrap` 恢复执行。第 7 章解释了 `yield` 中发生了什么。

当 `kerneltrap` 的工作完成后，它需要返回到被陷阱中断的任何代码。因为 `yield` 可能会扰乱 `sepc` 和 `sstatus` 中的先前模式，`kerneltrap` 在开始时保存了它们。现在它恢复这些控制寄存器并返回到 `kernelvec` (kernel/kernelvec.S:50)。`kernelvec` 从堆栈中弹出保存的寄存器并执行 `sret`，它将 `sepc` 复制到 pc 并恢复被中断的内核代码。

值得思考的是，如果 `kerneltrap` 由于定时器中断而调用 `yield`，陷阱返回是如何发生的。当 CPU 从用户空间进入内核时，xv6 会将该 CPU 的 `stvec` 设置为 `kernelvec`；您可以在 `usertrap` (kernel/trap.c:29) 中看到这一点。有一个时间窗口，内核已经开始执行，但 `stvec` 仍然设置为 `uservec`，在此期间不发生设备中断至关重要。幸运的是，RISC-V 在开始处理陷阱时总是禁用中断，而 xv6 直到设置 `stvec` 后才再次启用它们。

## **4.6 页面错误异常**

xv6 对异常的响应相当乏味：如果用户空间发生异常，内核会杀死出错的进程。如果在内核中发生异常，内核会 `panic`。真正的操作系统通常会以更有趣的方式响应。例如，许多内核使用页面错误来实现写时复制 (COW) `fork`。

为了说明写时复制 `fork`，请考虑第 3 章中描述的 xv6 的 `fork`。`fork` 使得子进程的初始内存内容与 `fork` 时的父进程相同。xv6 通过 `uvmcopy` (kernel/vm.c:306) 实现 `fork`，它为子进程分配物理内存并将父进程的内存复制到其中。如果父进程和子进程可以共享父进程的物理内存，这会更高效。然而，直接实现这一点将不起作用，因为它会导致父进程和子进程通过写入共享堆栈和堆来相互干扰执行。

通过适当使用页表权限和页面错误，父进程和子进程可以安全地共享物理内存。当使用没有页表映射的虚拟地址，或者映射的 PTE_V 标志被清除，或者映射的权限位（PTE_R、PTE_W、PTE_X、PTE_U）禁止尝试的操作时，CPU 会引发页面错误异常。RISC-V 区分三种页面错误：加载页面错误（当加载指令无法转换其虚拟地址时）、存储页面错误（当存储指令无法转换其虚拟地址时）和指令页面错误（当程序计数器中的地址无法转换时）。`scause` 寄存器指示页面错误的类型，`stval` 寄存器包含无法转换的地址。

COW `fork` 的基本计划是让父进程和子进程最初共享所有物理页面，但每个进程都将其映射为只读（清除 PTE_W 标志）。父进程和子进程都可以从共享的物理内存中读取。如果其中任何一个写入给定页面，RISC-V CPU 会引发页面错误异常。内核的陷阱处理程序通过分配一个新的物理内存页面并将其复制到故障地址映射到的物理页面中来响应。内核更改故障进程页表中的相关 PTE，使其指向副本并允许写入和读取，然后在导致故障的指令处恢复故障进程。由于 PTE 允许写入，重新执行的指令将不会出现故障。

写时复制需要簿记来帮助决定何时可以释放物理页面，因为每个页面可以根据 `fork`、页面错误、`exec` 和退出的历史由不同数量的页表引用。这种簿记允许一个重要的优化：如果一个进程发生存储页面错误并且物理页面仅从该进程的页表引用，则不需要复制。写时复制使 `fork` 更快，因为 `fork` 不需要复制内存。一些内存稍后必须在写入时复制，但通常大多数内存永远不需要复制。一个常见的例子是 `fork` 后跟 `exec`：`fork` 后可能会写入几页，但随后子进程的 `exec` 会释放从父进程继承的大部分内存。写时复制 `fork` 消除了复制此内存的需要。此外，COW `fork` 是透明的：应用程序无需修改即可从中受益。

除了 COW `fork` 之外，页表和页面错误的组合还开辟了广泛的有趣可能性。另一个广泛使用的功能称为延迟分配，它有两个部分。首先，当应用程序通过调用 `sbrk` 请求更多内存时，内核会记录大小的增加，但不会分配物理内存，也不会为新的虚拟地址范围创建 PTE。其次，在这些新地址之一上发生页面错误时，内核会分配一个物理内存页面并将其映射到页表中。与 COW `fork` 一样，内核可以透明地实现延迟分配。由于应用程序经常请求比它们需要的更多的内存，延迟分配是双赢的：对于应用程序从未使用的页面，内核根本不需要做任何工作。此外，如果应用程序要求将地址空间增长很多，那么没有延迟分配的 `sbrk` 代价很高：如果应用程序请求千兆字节的内存，内核必须分配并清零 262,144 个 4096 字节的页面。延迟分配允许将此成本分散到时间上。

另一方面，延迟分配会产生页面错误的额外开销，这涉及内核/用户转换。操作系统可以通过在每次页面错误时分配一批连续页面而不是一个页面，以及通过为此类页面错误专门化内核入口/出口代码来降低此成本。

另一个广泛使用的利用页面错误的功能是按需分页。在 `exec` 中，xv6 急切地将应用程序的所有文本和数据加载到内存中。由于应用程序可能很大并且从磁盘读取很昂贵，因此这种启动成本对用户来说可能是明显的：当用户从 shell 启动一个大型应用程序时，可能需要很长时间才能看到响应。为了改善响应时间，现代内核会创建用户地址空间的页表，但将页面的 PTE 标记为无效。在页面错误时，内核从磁盘读取页面内容并将其映射到用户地址空间。与 COW `fork` 和延迟分配一样，内核可以透明地实现此功能。

在计算机上运行的程序可能需要的内存超过计算机拥有的 RAM。为了优雅地应对，操作系统可以实现磁盘分页。其思想是只将一部分用户页面存储在 RAM 中，其余部分存储在磁盘上的分页区域中。内核将对应于存储在分页区域（因此不在 RAM 中）的内存的 PTE 标记为无效。如果应用程序尝试使用已分页到磁盘的页面，应用程序将发生页面错误，并且必须将页面分页进来：内核陷阱处理程序将分配一个物理 RAM 页面，从磁盘读取页面到 RAM，并修改相关 PTE 以指向 RAM。

如果需要将页面分页进来，但没有可用的物理 RAM 会发生什么？在这种情况下，内核必须首先通过将页面分页出去或驱逐到磁盘上的分页区域来释放物理页面，并将引用该物理页面的 PTE 标记为无效。驱逐是昂贵的，因此分页在不频繁时表现最佳：如果应用程序只使用它们的内存页面的一个子集，并且子集的并集适合 RAM。此属性通常被称为具有良好的局部性引用。

与许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现磁盘分页。无论硬件提供多少 RAM，计算机通常在几乎没有或没有可用物理内存的情况下运行。例如，云提供商在单台机器上复用许多客户以有效地利用其硬件成本。作为另一个例子，用户在智能手机上运行许多应用程序，而物理内存很少。在这种环境下，分配页面可能需要首先驱逐现有页面。因此，当可用物理内存稀缺时，分配是昂贵的。当可用内存稀缺时，延迟分配和按需分页特别有利。在 `sbrk` 或 `exec` 中急切地分配内存会产生额外的驱逐成本以使内存可用。此外，还有浪费急切工作的风险，因为在应用程序使用页面之前，操作系统可能已经将其驱逐。

其他结合分页和页面错误异常的功能包括自动扩展堆栈和内存映射文件。

## **4.7 现实世界**

蹦床和陷阱帧可能看起来过于复杂。一个驱动力是 RISC-V 在强制执行陷阱时故意尽可能少地做，以允许非常快速的陷阱处理的可能性，事实证明这很重要。因此，内核陷阱处理程序的前几条指令实际上必须在用户环境中执行：用户页表和用户寄存器内容。而且陷阱处理程序最初不知道有用的细节，例如正在运行的进程的身份或内核页表的地址。解决方案是可行的，因为 RISC-V 提供了受保护的地方，内核可以在进入用户空间之前在其中存放信息：`sscratch` 寄存器和指向内核内存但受缺少 `PTE_U` 保护的用户页表条目。xv6 的蹦床和陷阱帧利用了这些 RISC-V 功能。

如果内核内存映射到每个进程的用户页表中（具有适当的 PTE 权限标志），则可以消除对特殊蹦床页的需求。这也将消除从用户空间陷入内核时的页表切换需求。这反过来将允许内核中的系统调用实现利用当前进程的用户内存被映射，允许内核代码直接解引用用户指针。许多操作系统使用这些想法来提高效率。xv6 避免使用它们是为了减少由于意外使用用户指针而导致的内核安全错误的可能性，并减少确保用户和内核虚拟地址不重叠所需的一些复杂性。

生产操作系统实现了写时复制 `fork`、延迟分配、按需分页、磁盘分页、内存映射文件等。此外，生产操作系统将尝试使用所有物理内存，无论是用于应用程序还是缓存（例如，我们将在第 8.2 节中介绍的文件系统的缓冲区缓存）。在这方面，xv6 是天真的：您希望您的操作系统使用您购买的物理内存，但 xv6 不会。此外，如果 xv6 内存不足，它会向正在运行的应用程序返回错误或将其杀死，而不是例如驱逐另一个应用程序的页面。